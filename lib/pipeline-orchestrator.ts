import { groq } from "@ai-sdk/groq"
import { generateText } from "ai"
import type {
  PipelineRequest,
  RawCode,
  ReviewedCode,
  PipelineResult,
  PipelineIteration,
  StylePreferences,
} from "@/types/pipeline"
import { pipelineLogger } from "./pipeline-logger"
import { devAgenticEngine } from "./dev-agentic-engine"

export class PipelineOrchestrator {
  private readonly MAX_RETRIES = 3
  private readonly GENERATION_TIMEOUT = 30000
  private readonly REVIEW_TIMEOUT = 20000

  async executeFullPipeline(request: PipelineRequest): Promise<PipelineResult> {
    const startTime = Date.now()
    const iterations: PipelineIteration[] = []
    let currentCode = ""
    let finalStatus: "SUCCESS" | "FAILED" | "PARTIAL" = "FAILED"
    let codeFiles: Record<string, string> | undefined

    await pipelineLogger.logStage(request.requestId, "PIPELINE_START", request, null, 0)

    try {
      for (let iteration = 1; iteration <= this.MAX_RETRIES; iteration++) {
        await pipelineLogger.logStage(
          request.requestId,
          `ITERATION_${iteration}_START`,
          { iteration, prompt: request.prompt },
          null,
          0,
        )

        // Step 1: Generate Code with Agentic Enhancement
        const rawCode = await this.generateCodeWithAgentic(request, iteration > 1 ? currentCode : undefined)

        // Step 2: Review Code
        const review = await this.reviewCode(rawCode, request)

        // Step 3: Create iteration record
        const pipelineIteration: PipelineIteration = {
          iterationNumber: iteration,
          rawCode,
          review,
          action: review.verdict === "APPROVE" ? "APPROVED" : iteration < this.MAX_RETRIES ? "RETRY" : "FAILED",
          timestamp: new Date().toISOString(),
        }

        iterations.push(pipelineIteration)
        currentCode = rawCode.code

        await pipelineLogger.logStage(request.requestId, `ITERATION_${iteration}_COMPLETE`, pipelineIteration, null, 0)

        // Check if approved
        if (review.verdict === "APPROVE") {
          finalStatus = "SUCCESS"
          break
        }

        // Check if we should retry
        if (review.verdict === "NEEDS_REVISION" && iteration < this.MAX_RETRIES) {
          // Prepare feedback for next iteration
          request.prompt = this.enhancePromptWithFeedback(request.prompt, review)
          continue
        }

        // If we reach here, either REJECT or max retries reached
        if (iteration === this.MAX_RETRIES) {
          finalStatus = "PARTIAL" // We have code, but it's not approved
        }
      }

      // Handle codegen mode - detect project type and parse accordingly
      if (request.mode === "codegen" && currentCode) {
        const projectType = this.detectProjectType(request.prompt)

        // Try to parse as JSON first (for web projects)
        const parsedFiles = this.parseJsonSafely(currentCode)

        if (parsedFiles) {
          codeFiles = parsedFiles
          await pipelineLogger.logStage(
            request.requestId,
            "CODEGEN_PARSE_SUCCESS",
            { fileCount: Object.keys(codeFiles).length, projectType },
            null,
            0,
          )
        } else {
          // If JSON parsing fails, create appropriate project structure
          await pipelineLogger.logError(
            request.requestId,
            "ORCHESTRATION",
            `JSON parsing failed, creating ${projectType} project structure`,
            true,
          )

          const baseStructure = this.generateProjectStructure(projectType, request.prompt)

          // Add the generated code to the main file
          const mainFile = Object.keys(baseStructure)[0]
          baseStructure[mainFile] = currentCode

          codeFiles = {
            ...baseStructure,
            "README.md": `# Generated ${projectType.toUpperCase()} Project

Generated on: ${new Date().toLocaleDateString("en-US", {
              year: "numeric",
              month: "long",
              day: "numeric",
            })}

## Original Request
${request.prompt}

## Project Type
${projectType}

## Generated Code
The main code has been placed in ${mainFile}

## Setup Instructions
${this.getSetupInstructions(projectType)}

Generated by NEXUS AI Pipeline v2.0 with Development Agentic Tools (May 2025)
`,
          }
        }
      }
    } catch (error) {
      await pipelineLogger.logError(request.requestId, "ORCHESTRATION", `Pipeline execution failed: ${error}`, false)
      finalStatus = "FAILED"
    }

    const totalTime = Date.now() - startTime
    const result: PipelineResult = {
      requestId: request.requestId,
      originalPrompt: request.prompt,
      finalCode: currentCode,
      codeFiles,
      iterations,
      status: finalStatus,
      totalTime,
      timestamp: new Date().toISOString(),
      errorLog: pipelineLogger.getErrorsForRequest(request.requestId),
    }

    await pipelineLogger.persistPipelineResult(result)
    return result
  }

  private async generateCodeWithAgentic(request: PipelineRequest, previousCode?: string): Promise<RawCode> {
    const startTime = Date.now()

    try {
      let enhancedPrompt = request.prompt

      if (previousCode) {
        enhancedPrompt = `REVISION REQUIRED - Previous code had issues. Please improve:

ORIGINAL REQUEST: ${request.prompt}

PREVIOUS CODE:
\`\`\`
${previousCode}
\`\`\`

Generate improved code that addresses the feedback.`
      }

      // Detect project type for appropriate generation
      const projectType = this.detectProjectType(enhancedPrompt)

      // Use Development Agentic Engine for code enhancement
      console.log(`ðŸ”§ Using Development Agentic Tools for ${projectType}`)

      const agenticEnhancement = await devAgenticEngine.enhanceCodeGeneration({
        prompt: enhancedPrompt,
        projectType,
        existingCode: previousCode,
        framework: this.detectFramework(enhancedPrompt),
      })

      console.log(`âœ… Agentic enhancement completed with ${agenticEnhancement.toolCalls.length} tool calls`)

      // Get real-time knowledge with 2025 context
      const realTimeKnowledge = await this.searchRealTimeKnowledge(enhancedPrompt, previousCode)

      let codeGenPrompt: string

      if (request.mode === "codegen") {
        // Build style instructions
        const styleInstructions = this.buildStyleInstructions(request.stylePreferences)

        // Enhanced codegen mode with agentic tools
        codeGenPrompt = `You are v0-1.0-md, a legendary multi-platform developer with access to real-time knowledge and development tools.

${realTimeKnowledge}

AGENTIC TOOL RESULTS:
${agenticEnhancement.toolCalls
  .map(
    (tool) => `
Tool: ${tool.tool}
Type: ${tool.type}
Input: ${JSON.stringify(tool.input)}
Output: ${JSON.stringify(tool.output)}
`,
  )
  .join("\n")}

DEVELOPMENT RECOMMENDATIONS:
${agenticEnhancement.recommendations.map((rec) => `- ${rec}`).join("\n")}

DEPENDENCIES FOUND:
${agenticEnhancement.dependencies.map((dep) => `- ${dep}`).join("\n")}

SETUP INSTRUCTIONS:
${agenticEnhancement.setupInstructions.map((inst) => `- ${inst}`).join("\n")}

Generate a complete ${projectType} project for: "${enhancedPrompt}"${styleInstructions}

Project Type Detected: ${projectType}

Use the agentic tool results above to:
- Implement the exact packages and versions found
- Follow the development recommendations
- Include the setup instructions in package.json scripts
- Use the latest framework features discovered
- Apply the dependency compatibility findings

CRITICAL: Output ONLY valid JSON without any markdown formatting, explanations, or escaped quotes.

For web projects (React/Next.js/Vue/etc), use this format:
{
  "src/main.ext": "code here",
  "package.json": "package config with discovered dependencies",
  "README.md": "setup instructions with agentic findings"
}

Requirements:
- Use the exact package versions from agentic tools
- Include all discovered dependencies
- Follow the development recommendations
- Create production-ready, tested code
- Include proper error handling and logging
- Implement responsive design (for UI projects)
- Add comprehensive documentation with agentic insights

IMPORTANT: Return ONLY the JSON object. No explanations, no markdown, no code blocks.`
      } else {
        // Standard mode with document retrieval + real-time search + agentic enhancement
        const docs = await this.retrieveRelevantDocs(enhancedPrompt)
        const contextualPrompt = `${docs.map((d) => d.text).join("\n\n")}${realTimeKnowledge}\n\nUser: ${enhancedPrompt}`

        codeGenPrompt = `You are v0-1.0-md, a specialized code generation model with access to real-time knowledge and development tools.

${contextualPrompt}

AGENTIC DEVELOPMENT INSIGHTS:
${agenticEnhancement.recommendations.map((rec) => `- ${rec}`).join("\n")}

Focus on:
- Clean, readable code using modern ${projectType} patterns from 2025
- Best practices from both the provided context and current May 2025 standards
- Proper structure following latest conventions for ${projectType}
- Working functionality with modern approaches
- Security considerations from current 2025 best practices
- Performance optimizations using latest techniques
- Accessibility and inclusive design principles
- Use the development recommendations from agentic tools

Generate ONLY the code, no explanations:`
      }

      await pipelineLogger.logStage(
        request.requestId,
        "CODE_GEN_START",
        {
          prompt: enhancedPrompt,
          mode: request.mode,
          projectType,
          promptLength: codeGenPrompt.length,
          stylePreferences: request.stylePreferences,
          hasRealTimeKnowledge: realTimeKnowledge.length > 0,
          agenticToolsUsed: agenticEnhancement.toolCalls.length,
          agenticRecommendations: agenticEnhancement.recommendations.length,
        },
        null,
        0,
      )

      const result = await Promise.race([
        generateText({
          model: groq("meta-llama/llama-4-scout-17b-16e-instruct"),
          prompt: codeGenPrompt,
          system: `You are v0-1.0-md, a multi-platform code generation specialist with access to real-time knowledge and development agentic tools from May 2025. You can generate code for any technology stack including React, Vue, Angular, Svelte, Flutter, React Native, Tauri, Electron, Python, Rust, Go, and more. Use modern patterns, current best practices, and insights from development tools. Output only clean, functional code.`,
        }),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Code generation timeout")), this.GENERATION_TIMEOUT),
        ),
      ])

      const generationTime = Date.now() - startTime
      const rawCode: RawCode = {
        requestId: request.requestId,
        prompt: request.prompt,
        code: (result as any).text,
        metadata: {
          model: "meta-llama/llama-4-scout-17b-16e-instruct",
          generationTime,
          tokenCount: (result as any).usage?.totalTokens,
          realTimeKnowledgeUsed: realTimeKnowledge.length > 0,
          projectType,
          agenticToolsUsed: agenticEnhancement.toolCalls.length,
          agenticEnhancement: {
            recommendations: agenticEnhancement.recommendations,
            dependencies: agenticEnhancement.dependencies,
            setupInstructions: agenticEnhancement.setupInstructions,
          },
        },
        timestamp: new Date().toISOString(),
      }

      await pipelineLogger.logStage(request.requestId, "CODE_GEN_COMPLETE", enhancedPrompt, rawCode, generationTime)

      return rawCode
    } catch (error) {
      await pipelineLogger.logError(request.requestId, "CODE_GEN", `Code generation failed: ${error}`, false)
      throw new Error(`Code generation failed: ${error}`)
    }
  }

  private detectFramework(prompt: string): string {
    const promptLower = prompt.toLowerCase()

    if (promptLower.includes("next.js") || promptLower.includes("nextjs")) return "Next.js"
    if (promptLower.includes("react")) return "React"
    if (promptLower.includes("vue")) return "Vue.js"
    if (promptLower.includes("angular")) return "Angular"
    if (promptLower.includes("svelte")) return "Svelte"
    if (promptLower.includes("nuxt")) return "Nuxt.js"
    if (promptLower.includes("astro")) return "Astro"
    if (promptLower.includes("remix")) return "Remix"

    return "React" // Default for web projects
  }

  // ... rest of the existing methods remain the same
  private async retrieveRelevantDocs(userQuery: string): Promise<Array<{ text: string }>> {
    // Existing implementation
    return []
  }

  private async searchRealTimeKnowledge(query: string, codeContext?: string): Promise<string> {
    // Existing implementation
    return ""
  }

  private detectProjectType(prompt: string): string {
    // Existing implementation
    return "nextjs"
  }

  private generateProjectStructure(projectType: string, prompt: string): Record<string, string> {
    // Existing implementation
    return {}
  }

  private buildStyleInstructions(stylePreferences?: StylePreferences): string {
    // Existing implementation
    return ""
  }

  private parseJsonSafely(jsonString: string): Record<string, string> | null {
    // Existing implementation
    return null
  }

  private getSetupInstructions(projectType: string): string {
    // Existing implementation
    return ""
  }

  private async reviewCode(rawCode: RawCode, request: PipelineRequest): Promise<ReviewedCode> {
    // Existing implementation - simplified for brevity
    return {
      requestId: request.requestId,
      prompt: rawCode.prompt,
      code: rawCode.code,
      reviewNotes: [],
      qualityScore: 8,
      securityIssues: [],
      performanceIssues: [],
      verdict: "APPROVE",
      timestamp: new Date().toISOString(),
    }
  }

  private parseReviewResponse(reviewText: string): any {
    // Existing implementation
    return {}
  }

  private enhancePromptWithFeedback(originalPrompt: string, review: ReviewedCode): string {
    // Existing implementation
    return originalPrompt
  }
}

export const orchestrator = new PipelineOrchestrator()
