import type { DeploymentRequest, DeploymentResult } from "@/types/pipeline"

export class DeploymentService {
  private readonly VERCEL_API_URL = "https://api.vercel.com"
  private readonly GITHUB_API_URL = "https://api.github.com"

  async deployToVercel(request: DeploymentRequest): Promise<DeploymentResult> {
    try {
      // Step 1: Create GitHub repository
      const githubRepo = await this.createGitHubRepo(request.projectName, request.requestId)

      // Step 2: Push files to GitHub
      await this.pushFilesToGitHub(githubRepo, request.codeFiles)

      // Step 3: Deploy to Vercel
      const deploymentUrl = await this.createVercelDeployment(githubRepo, request.projectName)

      return {
        success: true,
        deploymentUrl,
        githubRepo: githubRepo.html_url,
      }
    } catch (error) {
      console.error("Deployment failed:", error)
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown deployment error",
      }
    }
  }

  private async createGitHubRepo(projectName: string, requestId: string) {
    const repoName = `nexus-${projectName.toLowerCase().replace(/[^a-z0-9]/g, "-")}-${requestId.slice(-8)}`

    const response = await fetch(`${this.GITHUB_API_URL}/user/repos`, {
      method: "POST",
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: repoName,
        description: `Generated by NEXUS AI Pipeline - ${projectName}`,
        private: false,
        auto_init: true,
      }),
    })

    if (!response.ok) {
      throw new Error(`GitHub repo creation failed: ${response.statusText}`)
    }

    return await response.json()
  }

  private async pushFilesToGitHub(repo: any, codeFiles: Record<string, string>) {
    // Get the default branch SHA
    const branchResponse = await fetch(`${this.GITHUB_API_URL}/repos/${repo.full_name}/git/refs/heads/main`, {
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
      },
    })

    const branchData = await branchResponse.json()
    const baseSha = branchData.object.sha

    // Create blobs for each file
    const blobs = await Promise.all(
      Object.entries(codeFiles).map(async ([filePath, content]) => {
        const blobResponse = await fetch(`${this.GITHUB_API_URL}/repos/${repo.full_name}/git/blobs`, {
          method: "POST",
          headers: {
            Authorization: `token ${process.env.GITHUB_TOKEN}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            content: Buffer.from(content).toString("base64"),
            encoding: "base64",
          }),
        })

        const blobData = await blobResponse.json()
        return {
          path: filePath,
          mode: "100644",
          type: "blob",
          sha: blobData.sha,
        }
      }),
    )

    // Create tree
    const treeResponse = await fetch(`${this.GITHUB_API_URL}/repos/${repo.full_name}/git/trees`, {
      method: "POST",
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        base_tree: baseSha,
        tree: blobs,
      }),
    })

    const treeData = await treeResponse.json()

    // Create commit
    const commitResponse = await fetch(`${this.GITHUB_API_URL}/repos/${repo.full_name}/git/commits`, {
      method: "POST",
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        message: "Initial commit - Generated by NEXUS AI Pipeline",
        tree: treeData.sha,
        parents: [baseSha],
      }),
    })

    const commitData = await commitResponse.json()

    // Update reference
    await fetch(`${this.GITHUB_API_URL}/repos/${repo.full_name}/git/refs/heads/main`, {
      method: "PATCH",
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        sha: commitData.sha,
      }),
    })
  }

  private async createVercelDeployment(repo: any, projectName: string): Promise<string> {
    // Create Vercel project
    const projectResponse = await fetch(`${this.VERCEL_API_URL}/v9/projects`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${process.env.VERCEL_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: repo.name,
        gitRepository: {
          type: "github",
          repo: repo.full_name,
        },
        framework: "nextjs",
        buildCommand: "npm run build",
        devCommand: "npm run dev",
        installCommand: "npm install",
        outputDirectory: ".next",
      }),
    })

    if (!projectResponse.ok) {
      throw new Error(`Vercel project creation failed: ${projectResponse.statusText}`)
    }

    const projectData = await projectResponse.json()

    // Trigger deployment
    const deploymentResponse = await fetch(`${this.VERCEL_API_URL}/v13/deployments`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${process.env.VERCEL_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: repo.name,
        gitSource: {
          type: "github",
          repo: repo.full_name,
          ref: "main",
        },
        projectSettings: {
          framework: "nextjs",
        },
      }),
    })

    if (!deploymentResponse.ok) {
      throw new Error(`Vercel deployment failed: ${deploymentResponse.statusText}`)
    }

    const deploymentData = await deploymentResponse.json()
    return `https://${deploymentData.url}`
  }
}

export const deploymentService = new DeploymentService()
